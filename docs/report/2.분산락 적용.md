# Redis 적용 보고서
이번 프로젝트에서 레디스를 사용하여 분산락과 캐싱을 중심으로, 적용 이유, 구현 과정에서의 고민, 선택한 방식을 정리했습니다.

## 분산락

### 분산락의 구현 방식 비교
Redis로 분산락을 구현하는 대표적인 방식은 크게 두 가지입니다.

- Pub/Sub 기반 락
  - 동작 방식: 특정 키에 대한 락이 해제되면, Redis Pub/Sub 기능을 이용해 모든 구독자에게 "락 해제" 이벤트를 전송.
  - 장점: 락이 해제되기 전까지 Redis에 반복적으로 접근하지 않으므로 부하가 적음.
  - 단점: 대규모 트래픽 환경에서는 모든 구독자에게 이벤트를 전달해야 하므로 네트워크 브로드캐스트 비용이 커짐.

- Spin Lock
  - 동작 방식: 락을 획득할 때까지 반복적으로 Redis에 "락 요청"을 보냄.
  - 장점: 단순 구현, 대규모 트래픽 환경에서도 브로드캐스트 비용이 없음.
  - 단점: 재시도 빈도가 높을 경우 Redis에 부하를 줄 수 있음.

### 선택한 방식: Spin Lock + Backoff
초기에는 Pub/Sub Lock을 사용하려 했지만, [medium Redisson SpinLocks 정리](https://danilavaratyntsev.medium.com/redisson-spinlocks-299974055d17)
를 보고, 장기적으로 서버 수가 늘어나고 트래픽이 증가할 것을 고려했을 때,
브로드캐스트 비용이 없는 Spin Lock이 더 적합하다고 판단했습니다.

다만, Spin Lock의 가장 큰 단점은 락을 기다리는 동안 Redis에 계속 요청을 보내 부하를 발생시킨다는 점입니다.
이를 완화하기 위해 백오프(Backoff) 전략을 적용했습니다.

### 백오프 전략: Full Jitter
AWS에서 소개한 [Exponential Backoff and Jitter](https://aws.amazon.com/ko/blogs/architecture/exponential-backoff-and-jitter/) 방식 중 Full Jitter를 채택했습니다. <br>
- Exponential Backoff: 재시도 간격을 점점 늘려가는 방식 <br>
- Full Jitter: 0 ~ (백오프 시간) 사이에서 랜덤한 딜레이를 추가 <br>
- 장점: 대량의 요청이 동시에 재시도되는 "스톰 현상"을 완화하고, Redis 요청을 분산시킬 수 있음 <br>

즉, 단순히 Thread.sleep(100)처럼 고정 대기 시간을 쓰는 대신, 100ms~1초 사이에서 랜덤하게 대기하며 락 재시도를 수행했습니다.

### 오더 생성 분산락 구조 변경
기존 오더 생성 로직은 다음과 같았습니다.
1. 재고 감소
2. 쿠폰 사용
3. 오더 생성
4. 오더 상품 생성

이 로직 전체에 @Transactional을 적용하면, 락을 잡고 있는 동안 전체 트랜잭션이 실행되어 락 점유 시간이 길어지는 문제가 발생합니다.

이를 해결하기 위해 구조를 다음과 같이 변경했습니다.

1. 락(트랜잭션(재고 감소)) → 락은 재고 감소 구간에서만 잡음
2. 2번째 트랜잭션 (쿠폰 사용, 오더, 오더 상품 생성) → 락을 해제한 뒤 처리

이렇게 하면 락 점유 시간이 짧아져 성능이 개선되고, 다른 요청도 빨리 락을 획득할 수 있습니다.

### 보상 로직
기존 하나의 트랜잭션이었던 useCase를 2개로 쪼개어, 데이터 적합성에 맞지 않는 상황이 발생했습니다.

1. 재고 감소시 에러 -> 트랜잭션 롤백으로 보상로직 필요없음.
2. 재고 감소 성공, 오더생성 트랜잭션에서 에러 -> 재고만 감소한 상태이기 때문에 보상로직 필요.

2번 시나리오를 방지하기 위해 보상 로직을 추가했습니다.

### MultiLock 적용
초기 구현에서는 상품 옵션마다 for문 안에서 개별로 락을 잡는 구조였습니다.

```java
    for (optionId : optionIds) {
        lock(optionId);
        (하나의 상품 재고 감소 로직)
        ...
        unlock(optionId);
    }
```
이 경우 주문 옵션 수가 많으면 락을 여러 번 잡았다 풀었다 하므로 성능이 떨어집니다.
이를 Redisson MultiLock으로 개선하여, 한 번의 호출로 여러 옵션 ID에 대한 락을 동시에 획득하도록 변경했습니다.