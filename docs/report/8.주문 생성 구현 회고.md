# 도메인 이벤트를 사용한 주문 생성 시 동시성 테스트 회고

## 목차
1. [개요](#1-개요)
2. [발생한 문제](#2-발생한-문제)
3. [근본 원인 해석](#3-근본-원인-분석)
4. [해결 및 대안](#4-해결-및-대안)
5. [결론](#5-결론)

### **1. 개요**

모놀리식 환경에서 마이크로서비스 아키텍처(MSA)의 도메인 분리 설계를 모방하기 위해, 
스프링 도메인 이벤트 리스너를 활용한 주문 생성 기능을 구현해보았다.

이벤트 리스너의 트랜잭션 설정을 아래와 같이 구성하여 주문, 재고, 쿠폰과 같은 각 도메인의 책임을 분리하고 결합도를 낮추는 것을 목표로 했다.

```java
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT);  
@Transactional(propagation = Propagation.REQUIRES_NEW);
```

이 설계는 주문 생성 트랜잭션이 성공적으로 커밋된 이후(AFTER_COMMIT), 재고 감소와 같은 후속 처리를 완전히 새로운 트랜잭션(REQUIRES_NEW)에서 실행시킨다. 
이를 통해 오케스트레이션 사가 패턴에서 특정 도메인이 과도한 책임을 지는 문제를 보완하고자 하였다.

### **2. 발생한 문제**

단일 스레드 환경에서는 모든 기능이 정상 동작하였으나, 동시성 테스트 환경에서는 다음과 같은 문제가 발생한다.

#### 예외 래핑(Exception Wrapping)
재고 부족 시 의도했던 RestApiException이 아닌 UnexpectedRollbackException이 발생한다. 이는 REQUIRES_NEW로 생성된 내부 트랜잭션의 롤백 예외가 외부 트랜잭션으로 전파되면서 스프링의 트랜잭션 프레임워크에 의해 래핑되기 때문이다.
#### DB 커넥션 풀 고갈
```java
HikariPool-1 - Connection is not available, request timed out...
```
다수의 스레드가 동시에 OrderCreatedEvent를 발행하면, 각각의 이벤트 리스너가 새로운 트랜잭션을 위해 커넥션 풀에서 커넥션을 점유한다. 이로 인해 동시 요청 수가 커넥션 풀의 크기를 초과하면 커넥션 부족 현상이 발생한다.
#### 상품 재고 감소 시 Stale Read (오래된 데이터 읽기)
간헐적으로 Stale Read가 발생하여 데이터 정합성이 깨진다. 
특정 스레드의 트랜잭션이 커밋되기 전에 다른 스레드가 새로운 트랜잭션으로 데이터를 읽게 되면, 변경 전의 데이터를 읽어 잘못된 재고 계산을 수행하게 된다.

### **3. 근본 원인 분석**

위 문제들의 근본 원인은 **물리적으로 분리되지 않은 자원의 경쟁**에 있다.

모놀리식 환경에서 도메인 이벤트를 과도하게 사용하면, 논리적으로는 책임이 분리된 것처럼 보이지만 결국 **동일한 데이터베이스와 커넥션 풀을 공유**한다. AFTER\_COMMIT과 REQUIRES_NEW 조합은 트랜잭션의 시작 시점을 지연시키고 분리할 뿐, 동시성 환경에서의 자원 경쟁 문제를 근본적으로 해결하지 못한다.

결과적으로 분산락, 이벤트 리스너, 내부 트랜잭션이 복잡하게 얽히면서 커밋 타이밍 차이로 인한 Stale Read와 커넥션 경쟁이 심화된다.

### **4. 해결 및 대안**

* 단기적 해결  
  테스트 환경에서는 동시 실행 스레드 수를 커넥션 풀 크기보다 작게 제한하거나, 커넥션 풀 크기를 늘려 안정성을 확보한다. 단위 테스트에서는 이벤트 리스너와 분산락을 Mock으로 처리하여 DB 커넥션 점유를 최소화한다.
* **장기적 아키텍처 제안**
    * **모놀리식 환경**: 핵심적인 데이터 정합성이 요구되는 주문-재고 차감과 같은 흐름은 **동기 호출 기반의 사가 패턴**을 유지하는 것이 더 합리적이다. 알림, 로깅 등 비핵심 로직만 이벤트 리스너를 통해 비동기로 분리하는 것을 추천한다.
    * **MSA 환경**: **Kafka와 같은 메시지 브로커**를 도입하여 서비스 간의 경계를 물리적으로 분리해야 한다. 이를 통해 각 서비스는 독립적인 데이터베이스와 자원을 갖게 되므로, 모놀리식 환경에서 발생했던 자원 경쟁 문제가 완화된다.

### **5. 결론**

모놀리식 환경에서 MSA의 도메인 책임을 분리하기 위한 이벤트 기반 설계는, 동시성 환경에서 **예상치 못한 자원 경쟁과 트랜잭션 문제를 야기할 수 있다.**

이를 통해 논리적 분리만으로는 물리적 자원 공유 문제를 해결할 수 없다는 한계를 확인하였다.

따라서 모놀리식 아키텍처에서는 핵심 비즈니스 흐름의 안정성을 위해 사가 패턴과 같은 동기 방식을 우선적으로 고려하고, 필요한 부분만 이벤트 기반으로 보완하는 전략이 효과적이다. 진정한 의미의 도메인 분리와 안정적인 동시성 처리를 위해서는 메시지 브로커를 통한 물리적 경계 분리가 필수적이다.